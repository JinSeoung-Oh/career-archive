1) 3D â†’ 2D ë³€í™˜ ì¡°ê±´
   -1. í•„ìš”í•œ ê²ƒ:
       - 3D point (X, Y, Z)
       - Intrinsic matrix (3Ã—3)
         ë§Œì•½ calibì˜ intrinsicì´ 3Ã—4ë¡œ ì£¼ì–´ì§„ ê²½ìš° = Reference camera ì¡´ì¬
         â†’ ë§ˆì§€ë§‰ ì—´ [3][0],[3][1],[3][2] baseline parameterë¥¼ ì œì™¸í•˜ê³  3Ã—3 intrinsic ë”°ë¡œ ì •ì˜
       - Extrinsic matrix (3Ã—4)
         [ğ‘…âˆ£ğ‘‡] í˜•íƒœ = Rotation matrix ğ‘… + Translation vector ğ‘‡

2) 3D â†’ 2D ê³„ì‚° ê³µì‹
   -1. Extrinsic ì ìš© (ì›”ë“œ â†’ ì¹´ë©”ë¼ ì¢Œí‘œ):
       |ğ‘‹â€²|    |ğ‘‹|
       |ğ‘Œâ€²| = ğ‘…|ğ‘Œ| + ğ‘‡
       |ğ‘â€²|    |ğ‘|
   -2. ì •ê·œí™” ì¢Œí‘œ(Normalized):
       ğ‘¥=ğ‘‹â€²/ğ‘â€² , ğ‘¦=ğ‘Œâ€²/ğ‘â€²
       ì—¬ê¸°ì„œ 
       ğ‘â€²= depth
   -3. Intrinsic ì ìš© (ì¹´ë©”ë¼ ì¢Œí‘œ â†’ ì´ë¯¸ì§€ ì¢Œí‘œ):
       ğ‘¢=ğ‘“_ğ‘¥â‹…ğ‘¥+ğ‘_ğ‘¥, ğ‘£=ğ‘“_ğ‘¦â‹…ğ‘¦+ğ‘_ğ‘¦
       - ğ‘“_ğ‘¥ = intrinsic[0,0]
       - ğ‘“_ğ‘¦ = intrinsic[1,1]
       - ğ‘_ğ‘¥ = intrinsic[0,2]
       - ğ‘_ğ‘¦ = intrinsic[1,2]
       ì¦‰,
       (ğ‘¢,ğ‘£)=ğ¾â‹…|ğ‘¥ ğ‘¦ 1|^T
â€‹
3) ì½”ë“œ ì˜ˆì‹œ (3D â†’ 2D)
import numpy as np

def project_point_3d_to_2d(X, K, R, T):
    """
    X: (3,) 3D world ì¢Œí‘œ
    K: (3,3) intrinsic
    R: (3,3) rotation
    T: (3,) translation
    return: (u,v), depth Z'
    """
    Xc = R @ X + T   # (X', Y', Z')
    x = Xc[0] / Xc[2]
    y = Xc[1] / Xc[2]

    u = K[0,0]*x + K[0,2]
    v = K[1,1]*y + K[1,2]
    return np.array([u,v]), Xc[2]

4) 2D â†’ 3D ë³€í™˜ (ì—­ìˆœ)
   - ë¨¼ì € (ğ‘‹â€²,ğ‘Œâ€²,ğ‘â€²)ë¥¼ ë§Œë“¤ì–´ì•¼ í•¨ â†’ (ğ‘¢,ğ‘£) í”½ì…€ ì¢Œí‘œì™€ depth ğ‘ê°€ í•„ìš”.
   - ì¦‰,
     (ğ‘‹â€²,ğ‘Œâ€²,ğ‘â€²)=(ğ‘¢â‹…ğ‘, ğ‘£â‹…ğ‘, ğ‘)
   - ê·¸ ë‹¤ìŒ Extrinsicê³¼ Intrinsicì„ ë¶„í•´í•œ ì‹ì„ ì—­ìœ¼ë¡œ ì ìš©:
     ğ‘‹_ğ‘¤=ğ‘…^(âˆ’1)â‹…ğ¾^(âˆ’1)â‹…((ğ‘‹â€²,ğ‘Œâ€²,ğ‘â€²)âˆ’ğ‘‡)

5) ì½”ë“œ ì˜ˆì‹œ (2D â†’ 3D)
def backproject_point_2d_to_3d(u, v, Z, K, R, T):
    """
    u,v: ì´ë¯¸ì§€ ì¢Œí‘œ
    Z: depth (ì¹´ë©”ë¼ ì¢Œí‘œê³„ ìƒ)
    K: (3,3) intrinsic
    R: (3,3) rotation
    T: (3,) translation
    return: (3,) 3D world ì¢Œí‘œ
    """
    # ì •ê·œí™” ì¢Œí‘œê³„ë¡œ ë³€í™˜
    x = (u - K[0,2]) / K[0,0]
    y = (v - K[1,2]) / K[1,1]

    # ì¹´ë©”ë¼ ì¢Œí‘œê³„ë¡œ í™•ì¥
    Xc = np.array([x*Z, y*Z, Z])

    # ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
    Xw = np.linalg.inv(R) @ (Xc - T)
    return Xw
