1. 용어 정리
   - 오일러 회전 정리 & 오일러 각(Euler angles): 3D 회전은 축-순서를 갖는 3번의 연속 회전(예: ZYX)으로 표현. 순서 의존적이며 짐벌락 존재.
   - 쿼터니언(Quaternion): 짐벌락 회피, 누적 회전 안정·효율적. 보통 (w, x, y, z) 또는 (x, y, z, w) 표기. (아래 코드는 (w, x, y, z) 권장)
   - Direction vector만으로는 회전(roll 포함) 전체를 복원할 수 없음 → 추가 기준축(예: up)이 필요.

2. 좌표계 주의
   - 아래 모든 공식은 오른손 좌표계, **ZYX(= yaw(Z) → pitch(Y) → roll(X))**를 가정합니다.
   - 데이터셋(KITTI 등) 별 좌표계/축 정의가 다르면 각도 해석·축 대응을 먼저 일치시키세요.

-------------------------------------------------------------------------
1) Euler(yaw, pitch, roll) → Quaternion(w, x, y, z)

ZYX 순서 가정 (yaw about Z, pitch about Y, roll about X).
입력·반환 단위: 라디안.

import numpy as np

def quat_from_euler_zyx(yaw, pitch, roll):
    """
    ZYX 회전(yaw→pitch→roll) 기준.
    반환: (w, x, y, z)
    """
    cy = np.cos(yaw * 0.5)
    sy = np.sin(yaw * 0.5)
    cp = np.cos(pitch * 0.5)
    sp = np.sin(pitch * 0.5)
    cr = np.cos(roll * 0.5)
    sr = np.sin(roll * 0.5)

    w = cr*cp*cy + sr*sp*sy
    x = sr*cp*cy - cr*sp*sy
    y = cr*sp*cy + sr*cp*sy
    z = cr*cp*sy - sr*sp*cy

    # 정규화(수치오차 방지)
    q = np.array([w, x, y, z], dtype=float)
    q /= np.linalg.norm(q)
    return tuple(q)
-------------------------------------------------------------------------
2) Rotation Matrix(3×3) → Quaternion(w, x, y, z)

import numpy as np

def is_rotation_matrix(R, atol=1e-6):
    # 직교성: R^T R = I, det(R)=+1
    should_be_I = R.T @ R
    I = np.eye(3)
    return (np.allclose(should_be_I, I, atol=atol) and
            np.isclose(np.linalg.det(R), 1.0, atol=1e-6))

def quat_from_rotmat(R):
    """
    3x3 회전행렬 → (w, x, y, z)
    trace 기반 안정 분기.
    """
    R = np.asarray(R, dtype=float)
    assert R.shape == (3,3), "R must be 3x3"
    # 필요시 근사 정규직교화 (노이즈가 큰 경우 옵션)
    # from scipy.linalg import polar; R, _ = polar(R)  # det>0 보정 필요

    t = np.trace(R)
    if t > 0.0:
        s = np.sqrt(t + 1.0) * 2.0
        w = 0.25 * s
        x = (R[2,1] - R[1,2]) / s
        y = (R[0,2] - R[2,0]) / s
        z = (R[1,0] - R[0,1]) / s
    else:
        # 대각성분 중 최댓값 분기
        if (R[0,0] > R[1,1]) and (R[0,0] > R[2,2]):
            s = np.sqrt(1.0 + R[0,0] - R[1,1] - R[2,2]) * 2.0
            w = (R[2,1] - R[1,2]) / s
            x = 0.25 * s
            y = (R[0,1] + R[1,0]) / s
            z = (R[0,2] + R[2,0]) / s
        elif R[1,1] > R[2,2]:
            s = np.sqrt(1.0 - R[0,0] + R[1,1] - R[2,2]) * 2.0
            w = (R[0,2] - R[2,0]) / s
            x = (R[0,1] + R[1,0]) / s
            y = 0.25 * s
            z = (R[1,2] + R[2,1]) / s
        else:
            s = np.sqrt(1.0 - R[0,0] - R[1,1] + R[2,2]) * 2.0
            w = (R[1,0] - R[0,1]) / s
            x = (R[0,2] + R[2,0]) / s
            y = (R[1,2] + R[2,1]) / s
            z = 0.25 * s

    q = np.array([w, x, y, z], dtype=float)
    q /= np.linalg.norm(q)
    return tuple(q)
*************************************************************************
import numpy as np
import math

def quat_from_rotmat_copysign(R):
    R = np.asarray(R, dtype=float)
    t = R[0,0] + R[1,1] + R[2,2]
    w = np.sqrt(max(0.0, 1.0 + t)) / 2.0
    x = np.sqrt(max(0.0, 1.0 + R[0,0] - R[1,1] - R[2,2])) / 2.0
    y = np.sqrt(max(0.0, 1.0 - R[0,0] + R[1,1] - R[2,2])) / 2.0
    z = np.sqrt(max(0.0, 1.0 - R[0,0] - R[1,1] + R[2,2])) / 2.0

    x = math.copysign(x, R[2,1] - R[1,2])
    y = math.copysign(y, R[0,2] - R[2,0])
    z = math.copysign(z, R[1,0] - R[0,1])

    q = np.array([w, x, y, z], dtype=float)
    q /= np.linalg.norm(q)
    return tuple(q)
-------------------------------------------------------------------------
3) Extrinsic [R|t] → Quaternion

Extrinsic = [R|t] 에서 **R(3×3)**만 뽑아 Method 2에 넣으면 됩니다.

주의: Extrinsic 정의가 “월드→카메라”인지 “카메라→월드”인지, 그리고 OpenCV의 R, t가 어떤 좌표계 변환을 의미하는지(전치 필요 여부)가 프로젝트마다 다릅니다.

OpenCV PnP/Calib 통상: X_cam = R * X_world + t.

만약 반대 정의라면 R.T를 사용해야 올바른 회전을 얻습니다.

*************************************************************************
*** lens distortion에 의한 왜곡은 여기서는 다루지 않았음 - lens distortion에 대한 파라미터(k1,k2,p1,p2,k3 …)가 주어지는 경우는 따로 계산
- (A) 단일 카메라 캘리브레이션
import cv2
import numpy as np

# 예: 체스보드 9x6 내부 코너
pattern_size = (9, 6)
square = 0.025  # 한 칸 크기(m)
objp = np.zeros((pattern_size[0]*pattern_size[1], 3), np.float32)
objp[:, :2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1, 2) * square

objpoints, imgpoints = [], []
for img_path in images:
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    ret, corners = cv2.findChessboardCorners(img, pattern_size)
    if ret:
        corners2 = cv2.cornerSubPix(img, corners, (11,11), (-1,-1),
                                    criteria=(cv2.TERM_CRITERIA_EPS+cv2.TERM_CRITERIA_MAX_ITER, 30, 1e-3))
        objpoints.append(objp)
        imgpoints.append(corners2)

ret, K, dist, rvecs, tvecs = cv2.calibrateCamera(
    objpoints, imgpoints, img.shape[::-1], None, None
)
print("RMS reprojection error:", ret)
print("K:\n", K)
print("dist:", dist.ravel())  # [k1 k2 p1 p2 k3 ...]

-(B) 왜곡 보정(언디스토션)
h, w = img.shape[:2]
newK, roi = cv2.getOptimalNewCameraMatrix(K, dist, (w,h), alpha=0.0)  # alpha=0: 크롭, 1: 전체
undist = cv2.undistort(img, K, dist, None, newK)

-(C) 포인트 언디스트ort → 정규화 좌표
pts = np.array([[[u, v]]], dtype=np.float32)  # Nx1x2
undist_norm = cv2.undistortPoints(pts, K, dist)  # Nx1x2, 왜곡 없는 정규화 좌표(x',y')
x_prime, y_prime = undist_norm[0,0]

-(D)
import cv2
flags = (cv2.fisheye.CALIB_RECOMPUTE_EXTRINSIC |
         cv2.fisheye.CALIB_CHECK_COND |
         cv2.fisheye.CALIB_FIX_SKEW)
rms, K, dist, rvecs, tvecs = cv2.fisheye.calibrate(
    objpoints, imgpoints, (w,h), None, None, flags=flags, criteria=(
        cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 1e-6
    )
)
*************************************************************************
-------------------------------------------------------------------------
4) Euler ↔ Direction Vector
   - 방향 벡터만으로는 roll이 결정되지 않습니다(자유도 1 부족).

yaw, pitch만으로 전방 벡터:

def forward_from_yaw_pitch(yaw, pitch):
    fx = np.cos(yaw) * np.cos(pitch)
    fy = np.sin(yaw) * np.cos(pitch)
    fz = np.sin(pitch)
    return np.array([fx, fy, fz], dtype=float)
